---
title: 'Redis数据结构: 整数集合'
categories: 开源项目
tags: [Redis]
date: 2016-10-28
---

Redis 实现的整数集合是一种只包含整数数值的集合，是一种非常简单的数据结构，它按照数值的大小依次存储这些整数。为了节省存储空间，整数集合使用基本的一个字节作为存储单位，在更大的数值插入时完成整个集合的类型提升。

C 语言对应的整数值可以存在不同大小的类型（short int、int、long 和 long long）中，这些类型使用的是不同数量的字节（分别是 1 字节、2 字节、4 字节 和 8 字节）。如果我们给整数集合统一使用 long long 类型（8 个字节），那么全部由小整数组成的集合将浪费多余的空间；而如果使用太小的类型，则许多大的整数数值将无法存储。因此，需要能够动态调节整数的类型，使得在不同的场景下，用不同的类型存储整数，而 Redis 正是这么做的。Redis 使用 int8_t（即一个字节）作为整数集合的基本存储单位，对于 short int、int、long、long long 对应的数值采用数组中连续的多个字节来保存。初始使用 int16_t 来保存整数值；一旦发现更大的数值存入的时候，对于原先的数组进行类型提升，使得更大的数值能够存入。了解了这个基本的想法以后，对于整数集合的设计和实现就变得很简单。

整数集合的实现在 intset.h 和 intset.c 中，我们先来看看它的结构：
```C
typedef struct intset {
    uint32_t encoding;     // 编码方式
    uint32_t length;       // 集合包含的元素数量
    int8_t contents[];     // 保存元素的数组
} intset;
```
在这个结构中，所有的整数保存在 contents 数组中，而这个数组的类型是 int8_t（一个字节，现行的计算机通常都是以一个字节为存储单位），但是这个数据结构并不保存 int8_t 类型的整数，而是用于保存 int16_t, int32_t 或 int62_t 的整数，具体保存的类型由 encoding 来决定。按照这样的保存方式，一个整数是由数组中的若干个连续的数合起来进行表示的，例如 int16_t 类型的整数 12345 就需要数组中的连续 2 个元素进行保存，分别是 48 和 57，这两个数的顺序由整数在内存中的存储顺序（大端或小端）决定。Redis 对于大端小端这两种存储方式的处理在 endianconv.h 和 endianconv.c 中，比较简单就不展开介绍了。
当创建一个新的整数集合时，默认将编码方式设置为 int16_t。当一个新的整数被添加的时候，此时需要检查该整数的类型是否是是 int16_t。若是，则直接找到需要插入的位置，将其插入；若不是 int16_t，而是更大的数据类型，则需要分配更大的空间，然后将数据从后到前依次放入新的位置。举个例子，一个 int16_t 类型的整数集合：

| 位 | 0至15位 | 16至31位 | 32至47位 |
|----|--------|----------|--------|
|元素 | 123 | 2322 | 56223|
此时我们需要插入一个 int32_t 类型的数据 123456，这个时候需要先分配一些新的空间：

| 位 | 0至15位 | 16至31位 | 32至47位 | 48位至127位 |
|---|--------|---------|--------|-------------|
|元素 | 123 | 2322 | 56223 | (新分配空间) |
然后由后向前依次将原来的数放到新的位置上，这里需要预先判断一下，新加入的数的位置，由于类型变大，所以新存入的整数不是最大的，就是最小的：

| 位 | 0至31位 | 32至63位 | 64至95位 | 96位至127位 |
|---|--------|---------|--------|-------------|
| 元素 | 123 | 2322 | 56223 | (新分配空间) |
由于 12345 比 原先的数都大，因此存入最后的位置，自此插入整数操作就完成了。由于需要挪动所有的元素，所以时间复杂度为 O(N)。

| 位 | 0至31位 | 32至63位 | 64至95位 | 96位至127位 |
|---|--------|---------|--------|-------------|
| 元素 | 123 | 2322 | 56223 | 123456 |
具体的代码可以查看 intsetMoveTail 函数，由于类型发生增大的情况（否则将高位的 0 去掉，可以直接存入当前的集合）只有可能有两种：

1. 比集合中所有的元素都大
2. 比集合中所有的元素都小，此时，插入的数为负数

所以插入的位置肯定在两端：

```C
static uint8_t _intsetValueEncoding(int64_t v) {
    // 查找最小的整型类型存储对应的整数值
    if (v < INT32_MIN || v > INT32_MAX)
        return INTSET_ENC_INT64;
    else if (v < INT16_MIN || v > INT16_MAX)
        return INTSET_ENC_INT32;
    else
        return INTSET_ENC_INT16;
}
static intset *intsetUpgradeAndAdd(intset *is, int64_t value) {
    uint8_t curenc = intrev32ifbe(is->encoding);
    uint8_t newenc = _intsetValueEncoding(value);
    int length = intrev32ifbe(is->length);
    // 判断若发生了类型增大，则在集合的哪头进行插入
    int prepend = value < 0 ? 1 : 0;
    // 调整整数结合的大小
    is->encoding = intrev32ifbe(newenc);
    is = intsetResize(is,intrev32ifbe(is->length)+1);
    //自后向前将值放入新的位置
    while(length--)
        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));
    // 将新的整数放入集合
    if (prepend)
        _intsetSet(is,0,value);
    else
        _intsetSet(is,intrev32ifbe(is->length),value);
    is->length = intrev32ifbe(intrev32ifbe(is->length)+1);
    return is;
}
```
注意，整数集合并没有提供降级操作，即一旦该整数集合被升级了以后，即使插入数据类型大的数被删除以后，对于该整数集合的提升并不会撤销。
