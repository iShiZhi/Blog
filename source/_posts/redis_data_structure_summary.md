---
title: 'Redis数据结构: 综述'
categories: 开源项目
tags: [Redis]
date: 2016-10-11
---

很有没有看开源项目的源代码了，正好最近公司的两个功能用了 Redis，觉得挺有意思的，就想拆开来看看，里面具体是怎么实现的，算是今年给自己留点小作业吧，希望能坚持看完它。同时，在这里做些记录，把这个过程中的一些体会记录下来，方便后面回顾的时候查阅。

在国庆期间，我大概花了 5 天左右的时间通读了一遍 huangz 写的《redis设计与实现（第二版）》，这本书大概 400 页左右，对于 Redis 的基本数据结构和实现原理有一个了解。然后，开始阅读最新的 Redis 源代码，在阅读的过程中写一些注释，同时在博客上写总结进行记录。huangz 针对“2.9.11”做了一个标注版的[源代码](https://github.com/huangz1990/redis-3.0-annotated)，对应地，我在阅读的过程中也对源代码添加了一些注释，放在我的 [GitHub](https://github.com/iShiZhi/redis) 上，不如 huangz 标注的详细，主要是给自己留下一些思考和记录，一些新的变化和功能也做上的标记，也可以给大家做一个参考。

这篇文章先大概介绍一下 Redis 的数据结构的设计初衷，作为后续各类数据结构详细介绍的综述。

众所周知，所有的计算机程序都需要考虑两类的因素：时间复杂度和空间复杂度。通常情况下，在存储系统中，这两者是相互矛盾的。使用的存储空间越大，那么进行各类操作时消耗的时间越少，而使用的存储空间越少，则操作时需要寻址或者解压缩就带来额外的时间开销，导致耗费的时间增多。在不同的使用场景中，我们对于时间和空间的敏感程度和要求并不相同。举个例子，我们需要存储一些整数，并对一些特定的数进行查找，那么我们可能会有如下的选择：

- 假设这些整数的范围确定，使用一个最小数到最大数的一个布尔数组来标记元素是否存在，这样查找操作的时间复杂度为 O(1)；
- 如果存入二分查找树，通过二分查找的方式进行查询，时间复杂度为 O(log N)；
- 如果这些数本身就存在链表中，那么查询时间就是 O(N)。

因此，使用场景对于数据结构的设计至关重要。Redis 针对各种不同的使用场景设计了不同的基础数据结构，这里先对设计思路进行一些简要的介绍，而后的博客将结合代码进行更详细解释。

### 简单动态字符串（Simple Dynamic String, SDS）

与 C 语言原生的表示动态字符串的方法有所不同，SDS 对于字符串常见的操作进行了优化：
- 增加了长度记录，使得 strlen 的时间复杂度从 O(N) 降为 O(1)；
- 通过保持空闲存储空间和惰性回收机制，减少对于 malloc 和 realloc 函数的调用，提升了 append 操作的性能

### 双端链表

这是一个基础的数据结构，包含了表头指针和表尾指针，每个节点中都有前驱指针和后继指针，加快了从表尾开始进行的各类操作。

### 字典

字典的底层实现是哈希表，大家都比较熟悉的数据结构，而 Redis 实现的哈希列表有如下的特点：
- 通过链表来解决冲突，通过 rehash 操作来降低冲突
- 针对不同的场景，使用不同的 rehash 操作和触发条件
- rehash 操作按照渐进式的方式进行

### 整数集合

整数集合是用来有序、无重复地保存多个整数值的数据结构。在 C 语言里，不同的数据类型占用的字节数是不同的，int8_t 占用 1 个字节，int16_t 占用 2 个字节，依次类推。而在大量的场景中，我们使用的整数的范围都较小，若使用 int64_t 的数组来作为整数集合的实现，则会浪费大量的空间。在这里，Redis 实现了一个根据集合中占用字节数最多的元素来确定数据的类型的数据结构，这个结构就是整数集合。

### 压缩列表

压缩列表是为了节约空间而设计的数据结构，它是由一系列特殊编码的内存块构成的列表。一个压缩列表可以包含多个节点，每个节点可以保存一个长度受限的字符数组（不以为\0结尾的char数组）或者整数。它通过特殊的规则，使得保存这类数据占用的内存空间最小。但是，它的所有操作都需要通过遍历完成，即时间复杂度为 O(N)。这是一种完全牺牲时间来换取空间节约的数据结构，不适合在节点数多太多的情况下进行使用。

### 跳跃表

即使链表中的元素是有序的，链表的查找、添加和删除的时间还是为 O(N)。跳跃表是在链表中元素是有序的基础上，通过增加额外的空间，加快各项操作的时间复杂度的数据结构，各项操作都可以达到 O(log N) 的时间复杂度。

### 快速列表

由于压缩列表的时间复杂度很高，为了提高压缩列表的时间复杂度，并且应对各类操作主要在链表两端完成的场景，Redis 发明了快速列表。它本质上是一个双端链表，而每个节点对应了一个压缩列表。通过限制压缩列表的存储空间和节点数量，以及引入 LZF 压缩算法对压缩列表进行进一步压缩，可以既保留压缩列表节省空间的特性，同时在对应的场景中，降低操作的时间复杂度。

以上大概讲了一下我对于 Redis 基本数据结构的设计思路的理解，后续将对各个数据结构进行展开介绍：

- Redis数据结构: 简单动态字符串
- Redis数据结构: 双端链表
- Redis数据结构: 字典
- Redis数据结构: 整数集合
- Redis数据结构: 压缩列表
- Redis数据结构: 跳跃表
- Redis数据结构: 快速列表
