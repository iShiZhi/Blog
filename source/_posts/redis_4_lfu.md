---
title: 'Redis 4.0 新功能：LFU 数据淘汰策略'
categories: 开源项目
tags: [Redis]
date: 2017-07-31
---

### 常用淘汰算法
淘汰算法的核心是预测数据未来被访问的可能性，优先淘汰概率最低的。
常用的淘汰算法有三种：
- FIFO：核心原则是如果数据最先进入缓存，则最先被淘汰，实现简单，但是太暴力
- LRU：核心原则是最近没有被使用的数据，在未来被使用的可能性也最低，最先淘汰
- LFU：核心原则是最近使用频率最低的数据，在未来被使用的可能性也最低，最先淘汰

### Redis LRU 实现
在 Redis 中实现的 LRU 算法使用了一些比较 tricky 的策略用来提升性能：
- 并不是取所有数据中访问时间最早的，而是随机选取 N 个数据项，淘汰掉时间最早的
- 使用随机选取的 N 个数据项建立备选池，只有当数据老于这个池中最老的数据，才会发生更替

在 Redis 4.0 的改版中，antirez 还针对使用多个 Redis 数据库做缓存做了优化，在老的版本中，多个数据库各自维护备选池，而在新的版本中，多个数据库维护一个共有的备选池，数据项额外加上数据库 ID。这样可以避免某一些数据库存储的都是老数据，另一些数据库存储的都是新数据的情况。

### Redis LFU 实现
在经过多轮优化尝试没有获得提升效果以后，antirez 认为这是 LRU 策略本身的短板，于是开始考虑实现 LFU 策略。他认为，从策略角度来看，LRU 是 LFU 的一种简化版。
在实现过程中，存在两个问题：
- 在 LRU 中，由于只要根据最近访问时间进行判断，这样可以使用一个链表，以及 O(1) 时间复杂度的操作进行维护，但是 LFU 需要维护所有数据的访问次数
- LFU 不能只保存访问次数，因为访问的模式会在变化，所以每隔一段时间，需要对访问次数对应的分值进行调整，而 Redis 中只保留了24 bits 来支持数据淘汰策略

对于第一个问题，antirez 沿用了 LRU 的处理方法：不严格按照访问次数进行维护，而是在需要选择淘汰数据的时候，随机采样 N 个数据项，淘汰掉次数最少的（感觉 antirez 很喜欢用随机采样进行近似，并且认为这个近似是有效的）
对于第二个问题，antirez 按照这样的方式分配 24 bits，其中 16 bits 用于记录最后调整计数器的时间，8 bits 用于记录计数器。
```
      +----------------+--------+
      +     16 bits    | 8 bits +
      +----------------+--------+
      + Last decr time | LOG_C  |
      +----------------+--------+
```
在计数器部分，antirez 使用了对数效果的计数器（使用概率的方式达到类似对数的效果），具体实现如下：
```c
  uint8_t LFULogIncr(uint8_t counter) {
      if (counter == 255) return 255;
      double r = (double)rand()/RAND_MAX;
      double baseval = counter - LFU_INIT_VAL;
      if (baseval < 0) baseval = 0;
      double p = 1.0/(baseval*server.lfu_log_factor+1);
      if (r < p) counter++;
      return counter;
  }
```
调整计数器的时机是在随机采样的时候，如果具体上次的调整时间已经超过阈值，且计数器的值超过阈值，则将计数器的值减半。
此外，对于新数据，分配的计数器是 5，而不是 0，否则新数据大概率被淘汰，从而导致策略失效。

### 参考资料
- [Random notes on improving the Redis LRU algorithm](http://antirez.com/news/109)
