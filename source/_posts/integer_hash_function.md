---
title: '整数哈希函数'
categories: 翻译
tags: [Redis]
date: 2016-10-16
---

在阅读 Redis Hash 源代码的过程中，看到一些整数的哈希函数，以前没有接触过，所以拜读了一下 Thomas Wang 写的文章，顺手翻译一下。 由于我对整个文章内容还没有完全理解，当前的翻译还有些不够通畅，等到查阅更多资料以后再进行修订。附上原文：http://web.archive.org/web/20071223173210/http://www.concentric.net/~Ttwang/tech/inthash.htm。

### 摘要

整数哈希函数是指以一个整数作为输入值，经过哈希变换以后得到一个整数作为输出值，所有通过这个函数得到的输出值具有均匀的分布。在这篇文章里，我们将讨论这个整数哈希函数的构造过程。

### 导论

哈希表是一种重要的数据结构。在所有介绍基础数据结构的书籍中都包含了哈希表的一些算法。但是，这些书籍中讨论的哈希算法总是适合某些特定的场景，导致这些算法在实际使用的过程中性能低下。
众所周知，整数的哈希函数是哈希函数中最基本的一种形式。它将一个整型的输入值进行哈希转换以后，得到一个整型的结果。对于这样的哈希函数，得到的输出值的分布必须是均匀的。这意味着，当输入值经过变换以后映射到不同的哈希桶的地址时，所有的哈希桶有相同的概率被映射。此外，相似的输入值应该被哈希变换得到差异比较大的输出值；并且希望，输入值一个 bit 位的变化，会造成输出值所有的 bit 位的变化。

### 哈希函数构造原则

一个设计优良的哈希函数必须是可逆的。如果存在 h(x) -> y，h(x) 的输入值的字长与输出值一样，且 h() 是可逆的，那么：

1. 如果 h(x1) == y1，那么存在 h_inverse(y1) == x1
2. 因为逆函数存在，所以不存在 x2 使得 x1 != x2 且 h(x2)

h(x1) == y1 且 h(x2) == y1 的情形被称为冲突，使用可逆的哈希函数将避免这样的情况。所有的输入值和输出值将一一对应。
此外，这个函数需要通过一系列的计算和变换造成“雪崩效应”。雪崩效应表示在输入值上产生了一个 bit 位的变化，将导致输出值在约一半的 bit 位上发生变化，这个新的值将在这一系列的计算中产生。
例如，运算 a = a + b 是可逆的，如果我们知道 b 的数值和计算后 a 的数值，那么我们就可以通过减法运算知道 a 的前值。

### Knuth的乘法哈希算法

在 Knuth 编写的”The Art of Computer Programming”（计算机程序设计艺术）一书的 6.4 部分，介绍了一种通过乘法的方式获得哈希函数的方法。用 2^32 的黄金分割（2654435761）乘以输入值来获取输出值。
由于 2654435761 和 2^32 没有公因子，这个算法产生了一个没有重合的，从输入值到输出值的完全映射。这个算法对于输入值较小的情况有比较好的哈希效果，但是对于输入值较大时的处理并不是很理想。因为对于所有基于乘法的哈希方法，对于输入值高位的 bit 值的改变，将无法造成输出值低位的 bit 值发生变化。

### Robert Jenkin 的 96bit 杂凑函数

Robert Jenkin 发明了一个基于减法、按位异或和位移的哈希函数。
本文中所有的源代码是按照 Java 的语法编写的，操作符 ‘>>>’ 表示无符号向右位移。如果要把源代码转成 C 语言，那么需要用 ‘uint32_t’ 替换 int，用 ‘uint64_t’ 替换 long。

```C
int mix(int a, int b, int c)
{
  a=a-b;  a=a-c;  a=a^(c >>> 13);
  b=b-c;  b=b-a;  b=b^(a << 8);
  c=c-a;  c=c-b;  c=c^(b >>> 13);
  a=a-b;  a=a-c;  a=a^(c >>> 12);
  b=b-c;  b=b-a;  b=b^(a << 16);
  c=c-a;  c=c-b;  c=c^(b >>> 5);
  a=a-b;  a=a-c;  a=a^(c >>> 3);
  b=b-c;  b=b-a;  b=b^(a << 10);
  c=c-a;  c=c-b;  c=c^(b >>> 15);
  return c;
}
```
变量 ‘c’ 是输入值，当杂凑结束以后，又是输出值。变量 ‘a’ 和 ‘b’ 是两个经过初始化的一位随机 bit 位。注意到，在内部计算过程中产生的中间结果是 96bits 的，远远大于输出值的 32bits。同样注意到从变量 ‘a’ 到变量 ‘c’ 的三次减法运算。每一列作用于其中一个变量，通过位移操作，将另外两个变量的信息混入。
与乘法算法类似，减法也无法将输入值中高位的 bit 值变化反应到输出值的低位 bit 值中。在 Robert Jenkin 算法中的 9 次位移操作，将输入值向右位移了总计 61bits，向左位移了总计 34bits。由于上述所有的运算会连续作用在输入值上，每一个异或操作将会使产生的可能状态倍增。通过这些不同的位移操作，将会至少产生 2^9 种不同的状态。这也是为什么输入值中 1 个 bit 的变化会导致在输出值中那么多位的变化。
另一方面，减法的特性保证了这个哈希函数的均匀分布。观察输入值和随机 bit 的单位减法运算。如果随机 bit 是0，则输入值保持不变，否则所有输入值中所有的 bit 都将翻转（1变为0，0变为1）。因为只有当输入值和随机 bit 位都为 1 时才会产生进位。将输入值减掉随机 bit 将会导致大约一半的输入值的 bit 发生翻转。所以即使输入值不是均匀的，通过与随机 bit 进行减法运算也会得到一个分布均匀的结果。

### 32bit 杂凑函数

基于 Robert Jenkin 在1997年提出的一个想法，我进行了相关的研究，并完成了一个整数的哈希函数。如下是我在2007年一月提出的最新版本。在函数中使用的常数是通过运行相关的搜索程序获得的。

```C
public int hash32shift(int key)
{
  key = ~key + (key << 15); // key = (key << 15) - key - 1;
  key = key ^ (key >>> 12);
  key = key + (key << 2);
  key = key ^ (key >>> 4);
  key = key * 2057; // key = (key + (key << 3)) + (key << 11);
  key = key ^ (key >>> 16);
  return key;
}
```
在补码表示下，(~x) + y 等价于 y - x - 1。
通过使用机器原生指令 ‘加补码’ 和 ‘位移 加’，上述的哈希函数可以在 HP9000 工作站上仅使用 11 个时钟周期完成。
通过多次的计算会增强输出值的随机性，但是同样会降低算法的性能。通过模拟运算发现，尽量在中间的计算中使用较小的位移数操作，而在前后的计算中使用较大的位移数操作是比较好的选择。

### Robert Jenkin 的 32bit 整数哈希函数

```C
uint32_t hash( uint32_t a)
{
   a = (a+0x7ed55d16) + (a<<12);
   a = (a^0xc761c23c) ^ (a>>19);
   a = (a+0x165667b1) + (a<<5);
   a = (a+0xd3a2646c) ^ (a<<9);
   a = (a+0xfd7046c5) + (a<<3);
   a = (a^0xb55a4f09) ^ (a>>16);
   return a;
}
```
这个版本的整数哈希函数通过操作一些整数常数来辅助获得哈希值。我怀疑这些常数值的具体数值并没有对整个哈希过程产生特别重要的影响，即使使用 16bits 的常数，也依然可以产生很好的效果。
但是这些常数对于获得一个完美的整数哈希函数还是有一定意义的。一个测试函数可以不断改变这些常数值来获得一个完美的整数哈希函数。

### 使用乘法来进行哈希

如果使用乘法来进行哈希过程，则需要一个机制将输入值的高位变化反应在输出值的低位上。bit 翻转是最佳的选择，但是实现起来比较慢。一个可行的替代方案是向左位移操作。
使用乘法进行哈希会陷入一些困境。一些硬件平台在硬件层面上支持整数的乘法操作，这样使得一次的乘法可以在 4 个或者更少的时钟周期里完成；但是对于另外的一些硬件平台而言，需要耗费 8 个或者更多的时钟周期。而另外一方面，通过位移操作实现的哈希过程可以在所有的平台上都有良好的表现。
一个折中的方案是将输入值乘以一个 bit 位稀疏的值，这样在乘法操作比较慢的硬件平台上，就可以通过 “位移 加” 操作来进行替代。例如乘数设置为 (4096 + 8 + 1)，对应的位移表达式为 (key + (key << 3)) + (key << 12)。
在几乎所有的机器上，一个 3bits 的位移加上一个加法运算可以在一个时钟周期里完成。例如，奔腾指令集中的 ‘lea’ 指令可以在一个时钟周期里实现 “位移 加” 操作。
函数 hash32shiftmult() 使用一个位移操作和乘法运算的组合来对输入值进行哈希操作。

```C
public int hash32shiftmult(int key)
{
  int c2=0x27d4eb2d; // a prime or an odd constant
  key = (key ^ 61) ^ (key >>> 16);
  key = key + (key << 3);
  key = key ^ (key >>> 4);
  key = key * c2;
  key = key ^ (key >>> 15);
  return key;
}
```

### 64bit 杂凑函数

```C
public long hash64shift(long key)
{
  key = (~key) + (key << 21); // key = (key << 21) - key - 1;
  key = key ^ (key >>> 24);
  key = (key + (key << 3)) + (key << 8); // key * 265
  key = key ^ (key >>> 14);
  key = (key + (key << 2)) + (key << 4); // key * 21
  key = key ^ (key >>> 28);
  key = key + (key << 31);
  return key;
}
```
由于 64bits 的位数比较多，所以需要更多的杂凑操作。

### 64bit 转换为 32bit 哈希函数

这类哈希函数的一个应用是将一个 64bit 的虚拟地址转为一个哈希表的索引值。由于函数的输出值的位数小于输入值，因此这类哈希函数不再是一一映射。
另外一个应用是将两个 32bit 整数转化为一个哈希值。

```C
public int hash6432shift(long key)
{
  key = (~key) + (key << 18); // key = (key << 18) - key - 1;
  key = key ^ (key >>> 31);
  key = key * 21; // key = (key + (key << 2)) + (key << 4);
  key = key ^ (key >>> 11);
  key = key + (key << 6);
  key = key ^ (key >>> 22);
  return (int) key;
}
```

### 并行操作

如果CPU可以在一个时钟周期里同时分发多个指令，那么可以考虑在公式中加入一些并发处理的机制。
例如，如下公式中的两个位移操作可以并发执行。但是，如果是一台有多个 ALU，但是只有一个位移单元的机器上，这样的想法并不能提高速度。

key ^= (key << 17) | (key >>> 16);

对于 32bit 位宽的操作，只有一些位移对才是可逆的。这些位移对是：(17,16) (16,17) (14,19) (19,14) (13,20) (20,13) (10,23) (23,10) (8,25) (25,8)
乘法运算可以并发执行，所有的奇数乘法运算都是可逆的。

key += (key << 3) + (key << 9); // key = key * (1 + 8 + 512)

对于一些特定的机器，bit 翻转操作可以在一个时钟周期里完成。对于所有的奇数个 bit 翻转，只要对于非翻转的 bit 位与 1 或 0 进行异或操作，这样的操作是可逆的。

key = (key | 64) ^ ((key >>> 15) | (key << 17));

然而，对于其它的一些机器或者编译器，运行这些代码可能会需要 4 个时钟周期。

### 使用伪随机

有一些关于这些杂凑函数是否可以用于伪随机过程的疑问。尽管上述的哈希过程看起来像是随机的，但是官方的建议是使用一个真正的伪随机数生成器来进行这个过程，例如 [Mercenne Twister](http://web.archive.org/web/20071223173210/http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html)。
所有在本文中出现的哈希函数都只进行了哈希相关的测试，并没有进行随机性的测试。

### 测试程序

[测试程序](http://web.archive.org/web/20071214220545/http://www.concentric.net/~Ttwang/tech/testchange.java)对不同的位移操作的量进行了雪崩效应的测试。这个程序检测了不同的 bit 位的值上是否发生了变化，保证了对于所有的输入值而言，这些位移量能够产生约 50% 左右的 bit 位的值发生变化。
这个测试程序打印出了所有的经过测试的算法的名字，以及经过了雪崩效应测试的参数值。

### 2次幂哈希表大小

因为 2 的次幂在计算机中计算速度快，因此程序员通常使用 2 的次幂作为哈希表的大小。整数哈希函数可以用于将主哈希过程获得的输出值映射到实际的存储地址。

addr = inthash(marginal_hash_value) & (tablesize - 1);

使用内置的整数哈希函数比对一个质数进行取余操作更快。一次的整数取余操作需要花费 18 个时钟周期甚至更多，主要取决于硬件平台的架构。

### 结论

在这篇文章中，我们讨论了一系列整数相关的哈希函数。Knuth 的乘法方法最简单，但是有一些已知的缺点。Robert Jenkins 的 96bits 杂凑函数可以作为整数哈希函数使用，只是对于比较大的输入值更适用。本文还介绍了一个专门用于整数哈希的函数。
此外，我们还在文章中介绍了一个用于优化哈希值的应用程序。
